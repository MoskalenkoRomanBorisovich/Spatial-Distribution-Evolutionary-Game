\documentclass[a4paper,12pt]{article}

%%% Работа с русским языком
\usepackage{cmap}					% поиск в PDF
\usepackage{mathtext} 				% русские буквы в фомулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы

%%% Дополнительная работа с математикой
\usepackage{amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{amsmath}
\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление

%% Номера формул
%\mathtoolsset{showonlyrefs=true} % Показывать номера только у тех формул, на которые есть \eqref{} в тексте.

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{float}


%% Шрифты
\usepackage{euscript}	 % Шрифт Евклид
\usepackage{mathrsfs} % Красивый матшрифт

%%% Работа с картинками
\usepackage{graphicx}  % Для вставки рисунков
\graphicspath{{images/}{images2/}}  % папки с картинками
\setlength\fboxsep{3pt} % Отступ рамки \fbox{} от рисунка
\setlength\fboxrule{1pt} % Толщина линий рамки \fbox{}
\usepackage{wrapfig} % Обтекание рисунков и таблиц текстом
\usepackage{caption}
\captionsetup{labelsep=period} %. вместо : в рис

\title{Использование numba cuda jit}
\author{Москаленко Роман}
\date{}

\begin{document}

\maketitle

\section{Введение}
Игра Новака и Мэя в классическом виде, при синхронной игре и подсчёте очков агентов, позволяет проводить вычисления для агентов отдельно, независимо друг от друга. Значит моделирование игры можно проводить на GPU для большей эффективности. 

Пока что были написаны две версии функции использующих numba.cuda.jit и соответственно работающих на GPU. Эти варианты и будут разобраны ниже

\section{GPU и cuda}

Перед объяснением работы написанных функций, есть несколько основных понятий и принципов, на которых основывается cuda код.

\subsection{Блоки и потоки}

При каждом запуске cuda функции мы обозначаем количество блоков и потоков в блоках, на которых будут производиться вычисления.  Количество блоков и потоков может быть как числом, так и двумерным или трёхмерным массивом, соответственно массивы будут задавать форму сетки блоков и потоков. Каждый поток в блоке будет выполнят весь код написанный в функции, уникальность действий каждого потока достигается за счёт возможности получить номер потока (как внутри блока, так и во всей сетке). Аналогично в случае, когда количество потоков и блоков задаётся массивом, можно узнать координаты потока в заданной сетке. Количество потоков в одном блоке ограничено $\le 1024$

\subsection{Память}

У GPU есть несколько доступных видов памяти, однако нас интересуют глобальная память(global memory) и разделяемая память (shared memory).

Глобальная память позволяет нам хранить данные необходимые для вычислений на самом девайсе. Что значительно уменьшает время обращения к переменным, по сравнению с памятью хоста. Желательно перекинуть всё необходимое для вычислений в Глобальную память, это можно сделать вне cuda функции используя cuda.array.

Разделяемая память выделяется отдельно для каждого блока, все потоки в блоке имеют к ней доступ. Её очень мало (от 16 до 40 килобайт.). Время обращения к разделяемой памяти меньше чем к глобальной примерно в 100 раз. Поэтому если поток обращается к чему-то в глобальной памяти несколько раз, или если потоки в блоке обращаются к одним и тем же переменным в глобальной памяти, их стоит подгрузить в разделяемую память и дальше работать с ней.

\section{Функция для простой кубической решётки}

\subsection{Описание алгоритма}

Есть главная функция evolve3D\_ 5, из которой потом вызываются cuda функции. Тут же просходит выделение глобальной памяти %написать глобальные массивы

Две вспомогательные cuda функции нужны для избежания лишних действий с памятью хоста. Первая обнуляет переданный массив, вторая копирует элементы из первого массива во второй. эти функции используются на глобальных массивах. Без них пришлось бы использовать cuda\_ to\_ device что сильно замедлит программу.

Основной код разбит на две функции culc\_ scores3D и new\_ strategies3D. Они написаны так, чтобы работать при с трёхмерной сеткой блоков и потоков. Основная идея заключается в том, чтобы каждый блок подгружал, кубический кусочек поля в разделяемую память, затем мы работаем со всеми агентами, кроме крайних, так как для них в разделяемую память загружены все соседи. Блоки смещены так, чтобы соседние блоки пересекались по двум слоям агентов, в итоге крайние агенты каждого блока обрабатываются соседними блоками.

%картинка с блоками и тем, как они расположены

Подгрузка происходит в начале каждой функции. Каждый поток загружает один, соответствующий элемент массива в shared memory. Затем следует команда cuda.sincthreads() которая означает, что потоки прдолжат выполнение программы только, когда все потоки дойдут, до этой метки ( то есть когда все потоки подгрузят свой кусочек массива). Далее мы останавливаем все потоки, отвечающие за края блока. Остальной код аналогичен коду в функциях без использования cuda.

В culc\_ scores3D мы подгружаем часть массива grid, а в new\_ stratagies часть массива scores. Так как для обработки одного агента, каждому потоку в функциях нужно обратиться к соответствующим массивам 27 раз. Остальные массивы подгружать не имеет смысла, так к ним потоки обращаются 1 раз.

% скрин с кодом, где выделяется память

\subsection{Время работы}

Данная функция показала наилучшее время. Она превосходит Cython и Numba. 

% Графики

На кластере благодаря тому, что Общее количество потоков хватает, чтобы запускать большое количество блоков одновременно, время работы почти не зависит от размера поля. При Большом времени эволюции выйгрыш по времени становится особенно большим, так как время не тратится на перенос массивов в глобальную память и обратно.

\section{Функция с таблицей соседей}

Данная функция работает почти так же долго, как функции с Cython и Numba. 

% Графики с временем работы

У такой разницы с предыдущей версией функции есть несколько причин.



\end{document}
